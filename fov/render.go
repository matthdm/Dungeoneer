package fov

import (
	"dungeoneer/constants"
	"image/color"

	"github.com/hajimehoshi/ebiten/v2"
	"github.com/hajimehoshi/ebiten/v2/vector"
)

var (
	shadowImage   = ebiten.NewImage(640, 480)
	triangleImage = ebiten.NewImage(640, 480) // solid white for masking
)

func ResizeShadowBuffer(w, h int) {
	if shadowImage.Bounds().Dx() != w || shadowImage.Bounds().Dy() != h {
		shadowImage = ebiten.NewImage(w, h)
		triangleImage = ebiten.NewImage(w, h)
		triangleImage.Fill(color.White)
	}
}

// DrawShadowMask renders the cached FOV triangles to the screen. It should be
// called every frame using the triangles generated by BuildShadowTriangles.
func DrawShadowMask(screen *ebiten.Image, tris []Triangle, camX, camY, camScale float64, cx, cy float64, tileSize int) {
	const offSetX = 1.0
	if len(tris) < 1 {
		return
	}

	// Fill entire screen with darkness first
	shadowImage.Clear()
	shadowImage.Fill(color.RGBA{0, 0, 0, constants.ShadowAlpha}) // semi-transparent black

	// Create a white image used to carve light
	lightMask := ebiten.NewImage(shadowImage.Bounds().Dx(), shadowImage.Bounds().Dy())
	lightMask.Fill(color.White)

	// Carve out triangles of light using source-out blend
	opt := &ebiten.DrawTrianglesOptions{Blend: ebiten.BlendSourceOut}

	for _, t := range tris {
		x0, y0 := worldToScreen(t.X1+offSetX, t.Y1, camX, camY, camScale, cx, cy, tileSize)
		x1, y1 := worldToScreen(t.X2+offSetX, t.Y2, camX, camY, camScale, cx, cy, tileSize)
		x2, y2 := worldToScreen(t.X3+offSetX, t.Y3, camX, camY, camScale, cx, cy, tileSize)

		verts := []ebiten.Vertex{
			{DstX: float32(x0), DstY: float32(y0), ColorA: 1},
			{DstX: float32(x1), DstY: float32(y1), ColorA: 1},
			{DstX: float32(x2), DstY: float32(y2), ColorA: 1},
		}

		shadowImage.DrawTriangles(verts, []uint16{0, 1, 2}, lightMask, opt)
	}

	// Composite shadow over the final screen
	screen.DrawImage(shadowImage, nil)
}
func DebugDrawRays(screen *ebiten.Image, rays []Line, camX, camY, camScale float64, cx, cy float64, tileSize int) {
	var offSetX float64 = 1
	for _, r := range rays {
		x1, y1 := worldToScreen(r.X1+offSetX, r.Y1, camX, camY, camScale, cx, cy, tileSize)
		x2, y2 := worldToScreen(r.X2+offSetX, r.Y2, camX, camY, camScale, cx, cy, tileSize)

		vector.StrokeLine(screen,
			float32(x1), float32(y1),
			float32(x2), float32(y2),
			1, color.RGBA{255, 255, 0, 180}, true)
	}

}

func DebugDrawWalls(screen *ebiten.Image, walls []Line, camX, camY, camScale, cx, cy float64, tileSize int) {
	var offSetX float64 = 1
	//var offsetY float64 = float64(tileSize) * 0.01 // Shift down visually in isometric space
	for _, wall := range walls {
		// Transform world coords to screen coords using isometric logic
		x1, y1 := worldToScreen(wall.X1+offSetX, wall.Y1, camX, camY, camScale, cx, cy, tileSize)
		x2, y2 := worldToScreen(wall.X2+offSetX, wall.Y2, camX, camY, camScale, cx, cy, tileSize)

		// Draw red line
		vector.StrokeLine(
			screen,
			float32(x1), float32(y1),
			float32(x2), float32(y2),
			1, color.RGBA{255, 0, 0, 255}, true,
		)
	}
}

func triangleVertices(x1, y1, x2, y2, x3, y3 float64) []ebiten.Vertex {
	return []ebiten.Vertex{
		{DstX: float32(x1), DstY: float32(y1), ColorA: 1},
		{DstX: float32(x2), DstY: float32(y2), ColorA: 1},
		{DstX: float32(x3), DstY: float32(y3), ColorA: 1},
	}
}
